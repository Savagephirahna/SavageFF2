local RS = game:GetService("ReplicatedStorage")
local gc = getgc(true)

local function findTargetConstant()
    local candidates = {}
    
    for _, obj in pairs(gc) do
        pcall(function()
            if type(obj) == "function" and islclosure(obj) and not isexecutorclosure(obj) then
                local protos = getprotos(obj)
                if protos and #protos == 1 then
                    local consts = getconstants(protos[1])
                    for _, const in pairs(consts) do
                        if type(const) == "number" and const > 1000000 and const < 10000000 then
                            table.insert(candidates, {value = const, func = obj})
                        end
                    end
                end
            end
        end)
    end
    
    return candidates
end

for _, obj in pairs(gc) do
    pcall(function()
        if type(obj) == "table" and rawlen(obj) == 19 then
            local last = rawget(obj, 19)
            if type(last) == "userdata" then
                for i = 2, 18 do
                    rawset(obj, i, math.random(1e6, 1e8))
                end
            end
        end
    end)
end

local detectedConstants = findTargetConstant()

if #detectedConstants > 0 then
    for _, candidate in ipairs(detectedConstants) do
        pcall(function()
            hookfunction(candidate.func, newcclosure(function() end))
        end)
    end
end

local remote = RS.Remotes.CharacterSoundEvent
local oldFire = remote.FireServer

hookfunction(remote.FireServer, newcclosure(function(self, ...)
    local args = {...}
    
    if type(args[1]) == "string" and #args[1] > 20 then
        if args[2] == "b51b07a5c14d" or args[2] == "error" then
            return
        end
    end
    
    return oldFire(self, ...)
end))

_G.b51b07a5c14d = false

local fakeLS = Instance.new("LocalScript")
fakeLS.Disabled = true
fakeLS.Parent = game:GetService("ReplicatedFirst")

for _, tbl in pairs(gc) do
    pcall(function()
        if type(tbl) == "table" then
            local mt = getrawmetatable(tbl)
            if mt and mt.__call then
                local oldCall = mt.__call
                rawset(mt, "__call", newcclosure(function(self, a, b, c, d, e, f)
                    if a and b and c and d and e and f then
                        if a > 1000 and b > 1000 then
                            return { 20.02 }
                        end
                    end
                    return oldCall(self, a, b, c, d, e, f)
                end))
                rawset(mt, "__tostring", nil)
            end
        end
    end)
end

task.wait(1)

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

local Window = Library:CreateWindow({
    Title = "Savage Hub",
    Footer = "by @wrl11 & @aylonthegiant | discord.gg/epNcR8Ce89",
    NotifySide = "Right",
    ShowCustomCursor = false,
    Mobile = {
        Enabled = true,
        Title = "Savage Hub",
        Icon = "rbxassetid://10723434711"
    }
})

local Tabs = {
    Catching = Window:AddTab("Catching", "hand"),
    Physics = Window:AddTab("Physics", "zap"),
    ["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local VIM = game:GetService("VirtualInputManager")
local ContextActionService = game:GetService("ContextActionService")

local Player = Players.LocalPlayer
while not Player do
    Player = Players.LocalPlayer
    wait()
end

-- Settings
local autocatchon = false
local catchdistance = 10
local magson = false
local magsrange = 0
local magsdelayon = false
local magsdelay = 0
local showhitboxon = false
local hitboxshape = "Sphere"
local hitboxcolor = Color3.fromRGB(128, 0, 128)
local hitboxes = {}
local catchresizeon = false
local catchresizerange = 10
local lmgg = 0
local magmode = "FTI"
local speedEnabled = false
local speedValue = 0.1
local movementLoop = nil
local jumpoweron = false
local jumpboost = 50
local nojpcooldownon = false
local njcconnections = {}
local pullvector = false
local pullvectorpower = 1
local pullvectordistance = 5
local clicktackleon = false
local clicktacklerange = 5
local ballpathOn = false
local ballpathColor = Color3.fromRGB(128,0,128)
local ballpathConnection
local deleteOOBEnabled = false

-- QB Throw Assist (visual-only) settings
local qbAssistEnabled = false
local qbAssistMaxDistance = 80
local qbProjectileSpeed = 120 -- studs/second approximate, change to match game feel; used only for prediction math
local qbAssistKey = Enum.KeyCode.Q
local qbIndicatorDuration = 1.6 -- seconds the visual stays on screen
local qbIndicatorGuiName = "SavageQBThrowAssist"

-- Utility functions (unchanged existing ones)
local function gotfb()
    local character = Player.Character
    if not character then return false end
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    for _, tool in pairs(character:GetChildren()) do
        if tool:IsA("Tool") and (tool.Name:lower():match("football") or tool:FindFirstChild("Handle")) then
            return true
        end
    end
    return false
end

local function findclosestball()
    local character = Player.Character
    if not character or not character:FindFirstChild("HumanoidRootPart") then return nil end
    local hrp = character.HumanoidRootPart
    local closestball, mindist = nil, math.huge
    for _, ball in pairs(Workspace:GetChildren()) do
        if ball.Name:lower():match("football") and ball:IsA("BasePart") and not ball.Anchored then
            local dist = (hrp.Position - ball.Position).Magnitude
            if dist < mindist then closestball, mindist = ball, dist end
        end
    end
    return closestball, mindist
end

local function hitboxx(oid)
    if not oid or hitboxes[oid] or not magson or not showhitboxon then return end
    local holder = oid:FindFirstAncestorOfClass("Model")
    if holder and Players:GetPlayerFromCharacter(holder) then return end
    local hitbox = Instance.new("Part")
    hitbox.Name = "Hitbox"
    hitbox.Size = Vector3.new(magsrange, magsrange, magsrange)
    hitbox.Anchored = true
    hitbox.CanCollide = false
    hitbox.Transparency = 0.2
    hitbox.Material = Enum.Material.ForceField
    hitbox.Color = Color3.fromRGB(128, 0, 128)
    hitbox.CastShadow = false
    hitbox.CFrame = oid.CFrame
    hitbox.Shape = Enum.PartType.Ball
    hitbox.Parent = oid
    local success, uistroke = pcall(function() return Instance.new("UIStroke") end)
    if success and uistroke then
        pcall(function()
            uistroke.Color = Color3.fromRGB(255,255,255)
            uistroke.Thickness = 1
            uistroke.Transparency = 0
            uistroke.Parent = hitbox
        end)
    end
    hitboxes[oid] = {part = hitbox}
    local connection
    connection = RunService.Heartbeat:Connect(function(dt)
        if not oid or not oid.Parent or not magson or not showhitboxon then
            if hitbox then hitbox:Destroy() end
            if connection then connection:Disconnect() end
            hitboxes[oid] = nil
            return
        end
        local holder = oid:FindFirstAncestorOfClass("Model")
        if holder and Players:GetPlayerFromCharacter(holder) then
            if hitbox then hitbox:Destroy() end
            if connection then connection:Disconnect() end
            hitboxes[oid] = nil
            return
        end
        hitbox.CFrame = oid.CFrame
        hitbox.Size = Vector3.new(magsrange, magsrange, magsrange)
        hitbox.Color = Color3.fromRGB(128, 0, 128)
    end)
end

local function fitbalsize()
    for oid, data in pairs(hitboxes) do
        if data and data.part then
            data.part.Size = Vector3.new(magsrange, magsrange, magsrange)
            data.part.Color = Color3.fromRGB(128, 0, 128)
        else
            if data and data.part then data.part:Destroy() end
            hitboxes[oid] = nil
        end
    end
end

local function remove()
    for oid, football in pairs(hitboxes) do
        if football.part then football.part:Destroy() end
    end
    hitboxes = {}
end

local function footballhitbox()
    if not magson then return end
    for _, child in pairs(Workspace:GetChildren()) do
        if child.Name:lower():match("football") and child:IsA("BasePart") then
            hitboxx(child)
        end
    end
end

local function getfutbal()
    local character = Player.Character
    if not (character and character:FindFirstChild("HumanoidRootPart")) then return nil end
    local playerpos = character.HumanoidRootPart.Position
    local closestfootballpart, mindist = nil, math.huge
    for _, child in pairs(Workspace:GetChildren()) do
        if child.Name:lower():match("football") and child:IsA("BasePart") then
            local dist = (child.Position - playerpos).Magnitude
            if dist < mindist and dist <= magsrange then closestfootballpart, mindist = child, dist end
        end
    end
    return closestfootballpart
end

local function catch(ball)
    if not ball then return nil end
    local character = Player.Character
    if not character then return end
    local catchleft = character:FindFirstChild("CatchLeft")
    local catchright = character:FindFirstChild("CatchRight")
    local closest, mindist = nil, math.huge
    local ballpos = ball.Position
    local rg = magsrange
    if catchleft and catchleft:IsA("BasePart") then
        local dist = (catchleft.Position - ballpos).Magnitude
        if dist < mindist and dist <= rg then closest, mindist = catchleft, dist end
    end
    if catchright and catchright:IsA("BasePart") then
        local dist = (catchright.Position - ballpos).Magnitude
        if dist < mindist and dist <= rg then closest, mindist = catchright, dist end
    end
    return closest
end

local function rrrrrrrsizenugget(character)
    if not character then return end
    if catchresizeon then
        local catchleft = character:FindFirstChild("CatchLeft")
        local catchright = character:FindFirstChild("CatchRight")
        if catchleft then
            catchleft.Size = Vector3.new(catchresizerange, catchresizerange, catchresizerange)
            catchleft.Transparency = 1
        end
        if catchright then
            catchright.Size = Vector3.new(catchresizerange, catchresizerange, catchresizerange)
            catchright.Transparency = 1
        end
    else
        local catchleft = character:FindFirstChild("CatchLeft")
        local catchright = character:FindFirstChild("CatchRight")
        if catchleft then
            catchleft.Size = Vector3.new(0.75, 5, 1.5)
            catchleft.Transparency = 1
        end
        if catchright then
            catchright.Size = Vector3.new(0.75, 5, 1.5)
            catchright.Transparency = 1
        end
    end
end

local function startMovementSystem()
    if not movementLoop then
        movementLoop = RunService.Heartbeat:Connect(function(dt)
            if not speedEnabled then return end
            local character = Player.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then return end
            local hrp = character.HumanoidRootPart
            local humanoid = character:FindFirstChild("Humanoid")
            if humanoid and humanoid.MoveDirection.Magnitude > 0 then
                local speedStudsPerSec = speedValue * 8
                local moveVector = humanoid.MoveDirection * speedStudsPerSec * dt
                hrp.CFrame = hrp.CFrame + moveVector
            end
        end)
    end
end

local function stopMovementSystem()
    if movementLoop then
        movementLoop:Disconnect()
        movementLoop = nil
    end
end

local function whenmoving(character)
    if not character then return end
    local humanoid = character:WaitForChild("Humanoid")
    local humanoidrootpart = character:WaitForChild("HumanoidRootPart")
    humanoid.StateChanged:Connect(function(_, newstate)
        if newstate == Enum.HumanoidStateType.Jumping and jumpoweron then
            task.wait(0.05)
            humanoidrootpart.AssemblyLinearVelocity = humanoidrootpart.AssemblyLinearVelocity + Vector3.new(0, jumpboost - 50, 0)
        end
    end)
end

local function njc(char)
    if not char then return end
    local hum = char:WaitForChild("Humanoid")
    local connection = RunService.Stepped:Connect(function()
        if nojpcooldownon then
            hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
        end
    end)
    njcconnections[char] = connection
end

local function findclosestsleveesor(maxdistance)
    local character = Player.Character
    if not character then
        return nil
    end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return nil
    end
    local closestdistance = maxdistance
    local closestcharacter = nil
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr == Player or plr.Team == Player.Team then
            continue
        end
        local targetchar = plr.Character
        if not targetchar then
            continue
        end
        local targethrp = targetchar:FindFirstChild("HumanoidRootPart")
        if not targethrp then
            continue
        end
        local hasfootball = false
        for _, item in ipairs(targetchar:GetChildren()) do
            if item:IsA("Tool") and item.Name:match("Football") then
                hasfootball = true
                break
            end
        end
        if not hasfootball then
            continue
        end
        local distance = (hrp.Position - targethrp.Position).Magnitude
        if distance < closestdistance then
            closestdistance = distance
            closestcharacter = targetchar
        end
    end
    return closestcharacter
end

local function beamProjectile(g, v0, x0, t1)
    local c = 0.125
    local p3 = 0.5*g*t1*t1 + v0*t1 + x0
    local p2 = p3 - (g*t1*t1 + v0*t1)/3
    local p1 = (c*g*t1*t1 + 0.5*v0*t1 + x0 - c*(x0+p3))/(3*c) - p2

    local curve0 = (p1 - x0).magnitude
    local curve1 = (p2 - p3).magnitude

    local b = (x0 - p3).unit
    local r1 = (p1 - x0).unit
    local u1 = r1:Cross(b).unit
    local r2 = (p2 - p3).unit
    local u2 = r2:Cross(b).unit
    b = u1:Cross(r1).unit

    local cf1 = CFrame.new(
        x0.x, x0.y, x0.z,
        r1.x, u1.x, b.x,
        r1.y, u1.y, b.y,
        r1.z, u1.z, b.z
    )
    local cf2 = CFrame.new(
        p3.x, p3.y, p3.z,
        r2.x, u2.x, b.x,
        r2.y, u2.y, b.y,
        r2.z, u2.z, b.z
    )
    return curve0, -curve1, cf1, cf2
end

local function TriggerTouchEvent()
    local Camera = workspace.CurrentCamera
    local xPos = Camera.ViewportSize.X / 2
    local yPos = Camera.ViewportSize.Y / 2
    VIM:SendTouchEvent(1, Enum.UserInputState.Begin.Value, xPos, yPos)
    task.wait(0.005)
    VIM:SendTouchEvent(1, Enum.UserInputState.End.Value, xPos, yPos)
end

-- UI Groups
local MagsGroup = Tabs.Catching:AddLeftGroupbox("Mags")
local FootballGroup = Tabs.Catching:AddLeftGroupbox("Football")
local SpeedGroup = Tabs.Catching:AddRightGroupbox("Speed")
local PullGroup = Tabs.Catching:AddRightGroupbox("Pull")

local JumpPowerGroup = Tabs.Physics:AddLeftGroupbox("Jump Power")
local PhysicsStuffGroup = Tabs.Physics:AddRightGroupbox("Jump Cooldown")
local DeleteOOBGroup = Tabs.Physics:AddRightGroupbox("Delete OOB")
local TackleGroup = Tabs.Physics:AddLeftGroupbox("Tackle")

local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu")

-- Add QB Throw Assist group (visual-only)
local QBAssistGroup = Tabs.Catching:AddRightGroupbox("QB Throw Assist (Visual Only)")

QBAssistGroup:AddToggle("qbassist", {
    Text = "Enable QB Throw Assist (Visual Only)",
    Default = false,
    Callback = function(Value)
        qbAssistEnabled = Value
    end
})

QBAssistGroup:AddSlider("qbmaxdist", {
    Text = "Max Distance",
    Min = 10,
    Max = 200,
    Default = qbAssistMaxDistance,
    Rounding = 1,
    Callback = function(Value)
        qbAssistMaxDistance = Value
    end
})

QBAssistGroup:AddSlider("qbprojspd", {
    Text = "Projectile Speed (visual)",
    Min = 20,
    Max = 300,
    Default = qbProjectileSpeed,
    Rounding = 1,
    Callback = function(Value)
        qbProjectileSpeed = Value
    end
})

QBAssistGroup:AddLabel("Assist Key"):AddKeyPicker("QBAssistKey", {
    Default = "Q",
    NoUI = true,
    Text = "Assist key (shows suggested aim indicator)"
})

-- Helper: find the best receiver (teammate) within max distance
local function findBestReceiver(maxDistance)
    if not Player.Character or not Player.Character:FindFirstChild("HumanoidRootPart") then return nil end
    local myPos = Player.Character.HumanoidRootPart.Position
    local best = nil
    local bestDist = maxDistance
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= Player then
            -- prefer teammates if teams exist, otherwise any other player
            local ok = true
            pcall(function()
                if Player.Team and plr.Team and Player.Team ~= plr.Team then
                    ok = false
                end
            end)
            if ok and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
                local pos = plr.Character.HumanoidRootPart.Position
                local dist = (pos - myPos).Magnitude
                if dist < bestDist then
                    bestDist = dist
                    best = plr
                end
            end
        end
    end
    return best
end

-- Helper: create an on-screen indicator at a world position (screen-space)
local function showAimIndicator(worldPos, duration)
    duration = duration or qbIndicatorDuration
    local camera = Workspace.CurrentCamera
    if not camera then return end
    local screenPos, onScreen = camera:WorldToViewportPoint(worldPos)
    if not onScreen then return end

    -- Clean up any previous gui
    pcall(function()
        local existing = CoreGui:FindFirstChild(qbIndicatorGuiName)
        if existing then existing:Destroy() end
    end)

    local gui = Instance.new("ScreenGui")
    gui.Name = qbIndicatorGuiName
    gui.ResetOnSpawn = false
    gui.Parent = CoreGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 36, 0, 36)
    frame.AnchorPoint = Vector2.new(0.5, 0.5)
    frame.Position = UDim2.new(0, screenPos.X, 0, screenPos.Y)
    frame.BackgroundTransparency = 0
    frame.BackgroundColor3 = Color3.fromRGB(255, 204, 0) -- yellow
    frame.BorderSizePixel = 0
    frame.Visible = true
    frame.Parent = gui

    local border = Instance.new("UICorner")
    border.CornerRadius = UDim.new(1, 0)
    border.Parent = frame

    local inner = Instance.new("Frame")
    inner.Size = UDim2.new(0, 22, 0, 22)
    inner.AnchorPoint = Vector2.new(0.5, 0.5)
    inner.Position = UDim2.new(0.5, 0.5, 0, 0)
    inner.BackgroundColor3 = Color3.fromRGB(255, 34, 34) -- red center
    inner.BorderSizePixel = 0
    inner.Parent = frame
    local innerCorner = Instance.new("UICorner")
    innerCorner.CornerRadius = UDim.new(1, 0)
    innerCorner.Parent = inner

    -- Fade out and destroy after duration
    spawn(function()
        local start = tick()
        while tick() - start < duration do
            local elapsed = tick() - start
            local alpha = 1 - (elapsed / duration)
            pcall(function() frame.BackgroundTransparency = 0.25 + (1 - alpha) * 0.75 end)
            task.wait(0.03)
        end
        pcall(function() gui:Destroy() end)
    end)
end

-- Compute a predicted intercept point (visual-only). Returns a Vector3 world position or nil.
local function computeInterceptPoint(targetCharacter, shooterPos, projSpeed)
    if not targetCharacter or not targetCharacter:FindFirstChild("HumanoidRootPart") then return nil end
    local targetHRP = targetCharacter.HumanoidRootPart
    local targetPos = targetHRP.Position
    local targetVel = Vector3.new(0,0,0)
    pcall(function() targetVel = targetHRP.Velocity end)
    local toTarget = targetPos - shooterPos
    local dist = toTarget.Magnitude
    if dist <= 0 then return targetPos end

    local t = dist / math.max(1, projSpeed) -- simple time estimate
    -- compensate for target movement
    local predicted = targetPos + targetVel * t

    -- compensate for projectile drop due to gravity (estimate)
    local g = workspace.Gravity or 196.2 -- fallback just in case
    -- vertical compensation: aim higher by 0.5 * g * t^2
    predicted = predicted + Vector3.new(0, 0.5 * g * t * t, 0)

    return predicted
end

-- Input handling: on user click while holding ball or pressing assist key, show visual suggestion (no automation)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    -- try to respect the library keypicker if present
    local pickedKey = qbAssistKey
    pcall(function()
        local kb = Options and Options.QBAssistKey
        if kb and kb.Value then
            local sval = tostring(kb.Value)
            -- try to map string to Enum.KeyCode (best-effort)
            local upper = sval:upper()
            for _, k in pairs(Enum.KeyCode:GetEnumItems()) do
                if tostring(k):upper():find(upper) then
                    pickedKey = k
                    break
                end
            end
        end
    end)

    if qbAssistEnabled then
        -- If user pressed the assist key
        if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == pickedKey then
            -- find best receiver and display prediction
            if not Player.Character or not Player.Character:FindFirstChild("HumanoidRootPart") then return end
            local receiver = findBestReceiver(qbAssistMaxDistance)
            if not receiver or not receiver.Character then
                pcall(function() Library:Notify({Title = "QB Assist", Description = "No receiver found in range.", Time = 2}) end)
                return
            end
            local shooterPos = Player.Character.HumanoidRootPart.Position
            local predicted = computeInterceptPoint(receiver.Character, shooterPos, qbProjectileSpeed)
            if predicted then
                showAimIndicator(predicted, qbIndicatorDuration)
                pcall(function() Library:Notify({Title = "QB Assist", Description = "Suggested aim shown (visual-only).", Time = 2}) end)
            end
            return
        end

        -- If the player clicks (likely throwing) while holding the ball, show indicator (visual-only)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            if gotfb() then
                if not Player.Character or not Player.Character:FindFirstChild("HumanoidRootPart") then return end
                local receiver = findBestReceiver(qbAssistMaxDistance)
                if not receiver or not receiver.Character then return end
                local shooterPos = Player.Character.HumanoidRootPart.Position
                local predicted = computeInterceptPoint(receiver.Character, shooterPos, qbProjectileSpeed)
                if predicted then
                    showAimIndicator(predicted, qbIndicatorDuration)
                end
            end
        end
    end
end)

-- ThemeManager and library recolor to window (red/yellow)
do
    local red = Color3.fromRGB(255, 34, 34)
    local yellow = Color3.fromRGB(255, 204, 0)

    pcall(function()
        if ThemeManager and ThemeManager.SetTheme then
            ThemeManager:SetTheme({
                Accent = yellow,
                Primary = red,
                Secondary = yellow,
                Background = red,
                Text = Color3.fromRGB(255,255,255)
            })
        end
    end)

    pcall(function()
        if Library and Library.SetAccentColor then
            Library:SetAccentColor(yellow)
        end
        if Library and Library.SetThemeColor then
            Library:SetThemeColor("Background", red)
            Library:SetThemeColor("Accent", yellow)
        end
    end)

    task.spawn(function()
        task.wait(0.1)
        pcall(function()
            if Window and type(Window) == "table" then
                for _, val in pairs(Window) do
                    if typeof(val) == "Instance" then
                        if val:IsA("Frame") or val:IsA("ScrollingFrame") or val:IsA("ImageLabel") or val:IsA("ImageButton") then
                            pcall(function() val.BackgroundColor3 = red end)
                        elseif val:IsA("TextLabel") or val:IsA("TextButton") then
                            pcall(function() val.BackgroundColor3 = red val.TextColor3 = yellow end)
                        end
                    end
                end
            end

            if Tabs and type(Tabs) == "table" then
                for _, tab in pairs(Tabs) do
                    pcall(function()
                        if typeof(tab) == "Instance" and (tab:IsA("Frame") or tab:IsA("ScrollingFrame")) then
                            tab.BackgroundColor3 = red
                        elseif type(tab) == "table" then
                            for _, v in pairs(tab) do
                                if typeof(v) == "Instance" then
                                    if v:IsA("Frame") or v:IsA("ScrollingFrame") then
                                        pcall(function() v.BackgroundColor3 = red end)
                                    elseif v:IsA("TextLabel") or v:IsA("TextButton") then
                                        pcall(function() v.BackgroundColor3 = red v.TextColor3 = yellow end)
                                    end
                                end
                            end
                        end
                    end)
                end
            end
        end)
    end)
end

-- Initialize character
if Player.Character then
    rrrrrrrsizenugget(Player.Character)
    whenmoving(Player.Character)
    njc(Player.Character)
end

Player.CharacterAdded:Connect(function(char)
    rrrrrrrsizenugget(char)
    whenmoving(char)
    njc(char)
end)

-- Main Loops and other original behavior remain unchanged from your script (mags, auto-catch, ball path, pull vector, OOB deletion, etc.)
RunService.Heartbeat:Connect(function(deltatime)
    if not magson then return end
    local cnp = tick()
    if magsdelayon and (cnp - lmgg) < magsdelay then return end
    local magthatbihfoo = getfutbal()
    if magthatbihfoo then
        local closestcatchpart = catch(magthatbihfoo)
        if closestcatchpart then
            if magmode == "CFrame" then
                magthatbihfoo.CFrame = closestcatchpart.CFrame
            else
                firetouchinterest(closestcatchpart, magthatbihfoo, 0)
                task.wait()
                firetouchinterest(closestcatchpart, magthatbihfoo, 1)
            end
        end
    end
    if magsdelayon then lmgg = cnp end
end)

Workspace.ChildAdded:Connect(function(child)
    if child.Name:lower():match("football") and magson and showhitboxon and child:IsA("BasePart") then
        hitboxx(child)
    end
end)

task.spawn(function()
    while task.wait(0.02) do
        if not autocatchon then continue end

        local ball, distance = findclosestball()
        if ball and distance <= catchdistance then
            TriggerTouchEvent()
        end
    end
end)

task.spawn(function()
    while task.wait(0.1) do
        if pullvector then
            local character = Player.Character
            if character then
                local humanoidrootpart = character:FindFirstChild("HumanoidRootPart")
                if humanoidrootpart then
                    for _, ball in pairs(Workspace:GetChildren()) do
                        if ball.Name:lower():match("football") and ball:IsA("BasePart") then
                            local distance = (humanoidrootpart.Position - ball.Position).Magnitude
                            if distance <= pullvectordistance then
                                local direction = (ball.Position - humanoidrootpart.Position).Unit
                                humanoidrootpart.AssemblyLinearVelocity = direction * pullvectorpower * 25
                            end
                        end
                    end
                end
            end
        end
    end
end)

task.spawn(function()
    while task.wait(1) do
        if deleteOOBEnabled then
            for _, obj in pairs(Workspace:GetChildren()) do
                if obj:IsA("BasePart") and obj.Position.Y < -100 then
                    obj:Destroy()
                end
            end
        end
    end
end)

UserInputService.InputBegan:Connect(function(input, gameprocessed)
    if gameprocessed then return end
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        if not clicktackleon then return end
        local slveesor = findclosestsleveesor(clicktacklerange)
        if slveesor and slveesor:FindFirstChild("HumanoidRootPart") then
            local character = Player.Character
            if not character then return end
            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end
            hrp.CFrame = slveesor.HumanoidRootPart.CFrame
        end
    end
end)

Library:Notify({
    Title = "Savage Hub",
    Description = "Script loaded successfully!",
    Time = 5,
})

Library:OnUnload(function()
    qbAssistEnabled = false
    magson = false
    autocatchon = false
    speedEnabled = false
    pullvector = false
    jumpoweron = false
    nojpcooldownon = false
    clicktackleon = false
    ballpathOn = false
    deleteOOBEnabled = false
    
    for _, data in pairs(hitboxes) do
        if data.part and data.part.Parent then 
            data.part:Destroy() 
        end
    end
    
    local character = Player.Character
    if character then
        if catchresizeon then
            local catchleft = character:FindFirstChild("CatchLeft")
            local catchright = character:FindFirstChild("CatchRight")
            if catchleft then catchleft.Size = Vector3.new(0.75, 5, 1.5) end
            if catchright then catchright.Size = Vector3.new(0.75, 5, 1.5) end
        end
    end
    
    for char, connection in pairs(njcconnections) do
        if connection then connection:Disconnect() end
    end
    njcconnections = {}
    
    stopMovementSystem()
    
    if ballpathConnection then 
        ballpathConnection:Disconnect() 
    end
    
    for _, obj in ipairs(Workspace.Terrain:GetChildren()) do
        if obj:IsA("Beam") and obj.Name == "BallPath" then obj:Destroy()
        elseif obj:IsA("Attachment") and obj.Name == "BallPathAttachment" then obj:Destroy() end
    end

    -- remove any indicator GUI
    pcall(function()
        local existing = CoreGui:FindFirstChild(qbIndicatorGuiName)
        if existing then existing:Destroy() end
    end)
end)