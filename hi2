-- SavageHub.lua
-- Place this LocalScript into StarterPlayerScripts in a Roblox Studio place you own.
-- Single-file "Savage Hub": draggable menu, sliders, VectorForce-based flying, touch/mobile friendly.
-- Use only in places you own or have permission to modify.

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")

local player = Players.LocalPlayer

-- Helper: wait for character
local function getCharacter()
	return player.Character or player.CharacterAdded:Wait()
end

local char = getCharacter()
local humanoid = char:FindFirstChild("Humanoid") or char:WaitForChild("Humanoid")
local hrp = char:FindFirstChild("HumanoidRootPart") or char:WaitForChild("HumanoidRootPart")

-- Savage Hub settings (defaults)
local SavageHub = {
	MenuVisible = true,
	ToggleKey = Enum.KeyCode.RightShift,
	Fly = false,
	FlySpeed = 100,         -- studs/sec target speed
	FlyForceMax = 300,      -- maximum force (N) clamp
	FlyResponsiveness = 35, -- higher -> snappier/stronger accel
	WalkSpeed = humanoid.WalkSpeed or 16,
	JumpPower = humanoid.JumpPower or 50,
}

-- ========== UI Creation ==========
local function createUI()
	local screenGui = Instance.new("ScreenGui")
	screenGui.Name = "SavageHubGUI"
	screenGui.ResetOnSpawn = false
	screenGui.Parent = player:WaitForChild("PlayerGui")
	-- Make sure it displays on top for mobile
	screenGui.IgnoreGuiInset = true

	-- Main draggable frame
	local main = Instance.new("Frame")
	main.Name = "Main"
	main.Size = UDim2.new(0, 360, 0, 260)
	main.Position = UDim2.new(0, 16, 0.45, -130)
	main.AnchorPoint = Vector2.new(0, 0.5)
	main.BackgroundColor3 = Color3.fromRGB(28, 28, 28)
	main.BorderSizePixel = 0
	main.Parent = screenGui
	main.ClipsDescendants = true

	-- Title bar (drag handle)
	local title = Instance.new("Frame")
	title.Name = "TitleBar"
	title.Size = UDim2.new(1, 0, 0, 42)
	title.Position = UDim2.new(0, 0, 0, 0)
	title.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	title.Parent = main
	title.Active = true -- allow input

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Name = "TitleLabel"
	titleLabel.Size = UDim2.new(1, -54, 1, 0)
	titleLabel.Position = UDim2.new(0, 12, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "Savage Hub"
	titleLabel.Font = Enum.Font.SourceSansBold
	titleLabel.TextSize = 20
	titleLabel.TextColor3 = Color3.fromRGB(255,255,255)
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = title

	-- Close/Hide button
	local closeBtn = Instance.new("TextButton")
	closeBtn.Name = "Close"
	closeBtn.Size = UDim2.new(0, 42, 0, 28)
	closeBtn.Position = UDim2.new(1, -48, 0, 7)
	closeBtn.BackgroundColor3 = Color3.fromRGB(160, 40, 40)
	closeBtn.Text = "X"
	closeBtn.Font = Enum.Font.SourceSansBold
	closeBtn.TextSize = 18
	closeBtn.TextColor3 = Color3.fromRGB(255,255,255)
	closeBtn.Parent = title

	-- Content area (below title)
	local content = Instance.new("Frame")
	content.Name = "Content"
	content.Size = UDim2.new(1, -12, 1, -52)
	content.Position = UDim2.new(0, 6, 0, 46)
	content.BackgroundTransparency = 1
	content.Parent = main

	local function makeToggle(name, y, state)
		local btn = Instance.new("TextButton")
		btn.Name = name.."Btn"
		btn.Size = UDim2.new(1, 0, 0, 36)
		btn.Position = UDim2.new(0, 0, 0, y)
		btn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
		btn.TextColor3 = Color3.fromRGB(235, 235, 235)
		btn.Font = Enum.Font.SourceSans
		btn.TextSize = 18
		btn.Text = name .. ": ".. (state and "ON" or "OFF")
		btn.Parent = content
		return btn
	end

	local flyBtn = makeToggle("Fly", 0, SavageHub.Fly)

	-- Slider builder: returns label and bar frame (bar.ChangeCallback will be set by caller)
	local function makeSlider(labelText, y, minVal, maxVal, step, getVal)
		local lbl = Instance.new("TextLabel")
		lbl.Name = labelText.."Lbl"
		lbl.Size = UDim2.new(0.5, -6, 0, 22)
		lbl.Position = UDim2.new(0, 0, 0, y)
		lbl.BackgroundTransparency = 1
		lbl.Text = labelText .. ": " .. tostring(getVal())
		lbl.Font = Enum.Font.SourceSans
		lbl.TextSize = 14
		lbl.TextColor3 = Color3.fromRGB(230,230,230)
		lbl.TextXAlignment = Enum.TextXAlignment.Left
		lbl.Parent = content

		local bar = Instance.new("Frame")
		bar.Name = labelText.."Bar"
		bar.Size = UDim2.new(0.5, -6, 0, 26)
		bar.Position = UDim2.new(0.5, 6, 0, y)
		bar.BackgroundColor3 = Color3.fromRGB(70,70,70)
		bar.Parent = content
		bar.Active = true -- accept touch

		local fill = Instance.new("Frame")
		fill.Name = "Fill"
		fill.Size = UDim2.new(0, 0, 1, 0)
		fill.Position = UDim2.new(0, 0, 0, 0)
		fill.BackgroundColor3 = Color3.fromRGB(110,160,255)
		fill.Parent = bar

		local knob = Instance.new("ImageButton")
		knob.Name = "Knob"
		knob.Size = UDim2.new(0, 28, 0, 26)
		knob.BackgroundTransparency = 1
		knob.Image = "rbxassetid://3926305904"
		knob.Position = UDim2.new(0, -14, 0, 0)
		knob.Parent = bar
		knob.Active = true

		local function setFromValue(val)
			local t = math.clamp((val - minVal) / (maxVal - minVal), 0, 1)
			fill.Size = UDim2.new(t, 0, 1, 0)
			knob.Position = UDim2.new(t, -14, 0, 0)
			lbl.Text = labelText .. ": " .. tostring(val)
		end

		-- Dragging logic supporting mouse & touch
		local dragging = false
		local dragInput

		local function updateFromInputPos(pos)
			local absX = pos.X
			local barAbsPos = bar.AbsolutePosition.X
			local barWidth = bar.AbsoluteSize.X
			local rel = math.clamp((absX - barAbsPos) / barWidth, 0, 1)
			local raw = minVal + (maxVal - minVal) * rel
			local stepped = minVal + math.floor((raw - minVal) / step + 0.5) * step
			stepped = math.clamp(stepped, minVal, maxVal)
			setFromValue(stepped)
			return stepped
		end

		knob.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = true
				dragInput = input
			end
		end)
		knob.InputEnded:Connect(function(input)
			if input == dragInput then
				dragging = false
				dragInput = nil
			end
		end)
		bar.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				local stepped = updateFromInputPos(input.Position)
				if bar.ChangeCallback then bar.ChangeCallback(stepped) end
			end
		end)
		UserInputService.InputChanged:Connect(function(input)
			if dragging and input == dragInput then
				if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
					local stepped = updateFromInputPos(input.Position)
					if bar.ChangeCallback then bar.ChangeCallback(stepped) end
				end
			end
		end)

		-- initialize
		setFromValue(getVal())

		return lbl, bar
	end

	-- Create sliders (spaced vertically)
	local flySpeedLbl, flySpeedBar = makeSlider("FlySpeed", 48, 10, 600, 1, function() return SavageHub.FlySpeed end)
	local flyForceLbl, flyForceBar = makeSlider("FlyForceMax", 86, 50, 4000, 10, function() return SavageHub.FlyForceMax end)
	local respLbl, respBar = makeSlider("Responsiveness", 124, 1, 200, 1, function() return SavageHub.FlyResponsiveness end)
	local walkLbl, walkBar = makeSlider("WalkSpeed", 162, 0, 500, 1, function() return SavageHub.WalkSpeed end)
	local jumpLbl, jumpBar = makeSlider("JumpPower", 200, 0, 500, 1, function() return SavageHub.JumpPower end)

	-- Mobile-friendly always-visible toggle button (bottom-left)
	local toggleBtn = Instance.new("TextButton")
	toggleBtn.Name = "ToggleBtn"
	toggleBtn.Size = UDim2.new(0, 56, 0, 56)
	toggleBtn.Position = UDim2.new(0, 12, 1, -72)
	toggleBtn.AnchorPoint = Vector2.new(0, 0)
	toggleBtn.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
	toggleBtn.Text = "Sav\nHub"
	toggleBtn.TextWrapped = true
	toggleBtn.Font = Enum.Font.SourceSansBold
	toggleBtn.TextSize = 14
	toggleBtn.TextColor3 = Color3.fromRGB(255,255,255)
	toggleBtn.Parent = screenGui
	toggleBtn.AutoButtonColor = true
	toggleBtn.ZIndex = 50
	-- make toggle button draggable slightly so it doesn't block UI permanently
	local tDragging = false
	local tDragInput, tDragStartPos, tStartPos

	toggleBtn.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			-- short press toggles; long-drag moves button
			tDragInput = input
			tDragStartPos = input.Position
			tStartPos = toggleBtn.Position
			tDragging = true
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if tDragging and input == tDragInput then
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				local delta = input.Position - tDragStartPos
				-- calculate new position in pixels and clamp to viewport
				local view = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1280, 720)
				local newX = (tStartPos.X.Scale == 0 and tStartPos.X.Offset or 0) + delta.X
				local newY = (tStartPos.Y.Scale == 0 and tStartPos.Y.Offset or 0) + delta.Y
				newX = math.clamp(newX, 0, view.X - toggleBtn.AbsoluteSize.X)
				newY = math.clamp(newY, 0, view.Y - toggleBtn.AbsoluteSize.Y)
				toggleBtn.Position = UDim2.new(0, newX, 0, newY)
			end
		end
	end)
	toggleBtn.InputEnded:Connect(function(input)
		if input == tDragInput then
			tDragging = false
			-- If it was a quick tap (small movement), treat as toggle
			local moved = (input.Position - tDragStartPos).Magnitude
			if moved < 10 then
				SavageHub.MenuVisible = not SavageHub.MenuVisible
				main.Visible = SavageHub.MenuVisible
			end
			tDragInput = nil
		end
	end)

	-- Button callbacks
	flyBtn.MouseButton1Click:Connect(function()
		SavageHub.Fly = not SavageHub.Fly
		flyBtn.Text = "Fly: " .. (SavageHub.Fly and "ON" or "OFF")
	end)
	-- Also support touch activation for toggle (in case MouseButton1 doesn't fire on some devices)
	flyBtn.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			SavageHub.Fly = not SavageHub.Fly
			flyBtn.Text = "Fly: " .. (SavageHub.Fly and "ON" or "OFF")
		end
	end)

	closeBtn.MouseButton1Click:Connect(function()
		SavageHub.MenuVisible = not SavageHub.MenuVisible
		main.Visible = SavageHub.MenuVisible
	end)
	closeBtn.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.Touch then
			SavageHub.MenuVisible = not SavageHub.MenuVisible
			main.Visible = SavageHub.MenuVisible
		end
	end)

	-- Toggle with keyboard (desktop)
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		if input.KeyCode == SavageHub.ToggleKey then
			SavageHub.MenuVisible = not SavageHub.MenuVisible
			main.Visible = SavageHub.MenuVisible
		end
	end)

	-- Connect slider changes to settings
	flySpeedBar.ChangeCallback = function(v)
		SavageHub.FlySpeed = v
		flySpeedLbl.Text = "FlySpeed: " .. tostring(v)
	end
	flyForceBar.ChangeCallback = function(v)
		SavageHub.FlyForceMax = v
		flyForceLbl.Text = "FlyForceMax: " .. tostring(v)
	end
	respBar.ChangeCallback = function(v)
		SavageHub.FlyResponsiveness = v
		respLbl.Text = "Responsiveness: " .. tostring(v)
	end
	walkBar.ChangeCallback = function(v)
		SavageHub.WalkSpeed = v
		walkLbl.Text = "WalkSpeed: " .. tostring(v)
		if humanoid and humanoid.Parent and not SavageHub.Fly then
			pcall(function() humanoid.WalkSpeed = SavageHub.WalkSpeed end)
		end
	end
	jumpBar.ChangeCallback = function(v)
		SavageHub.JumpPower = v
		jumpLbl.Text = "JumpPower: " .. tostring(v)
		if humanoid and humanoid.Parent then
			pcall(function() humanoid.JumpPower = SavageHub.JumpPower end)
		end
	end

	-- ========== Dragging for the main menu ==========
	local dragging = false
	local dragInput = nil
	local dragStartPos = Vector2.new(0,0)
	local guiStartPos = Vector2.new(0,0)

	title.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragInput = input
			dragStartPos = input.Position
			guiStartPos = Vector2.new(main.AbsolutePosition.X, main.AbsolutePosition.Y)
		end
	end)
	title.InputEnded:Connect(function(input)
		if input == dragInput then
			dragging = false
			dragInput = nil
		end
	end)
	UserInputService.InputChanged:Connect(function(input)
		if dragging and input == dragInput then
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				local delta = input.Position - dragStartPos
				local newPos = guiStartPos + delta
				-- clamp to viewport
				local view = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1280, 720)
				local clampedX = math.clamp(newPos.X, 0, view.X - main.AbsoluteSize.X)
				local clampedY = math.clamp(newPos.Y, 0, view.Y - main.AbsoluteSize.Y)
				main.Position = UDim2.new(0, clampedX, 0, clampedY)
			end
		end
	end)

	return screenGui, {main = main, flyBtn = flyBtn, toggleBtn = toggleBtn}
end

local gui, widgets = createUI()

-- ========== VectorForce Flight Implementation ==========
local flying = false
local vf -- VectorForce
local attach -- Attachment
local forceConn -- Heartbeat connection

local function createVectorForceFor(part)
	-- create an attachment and VectorForce on the HRP
	local existingAttach = part:FindFirstChild("SavageHub_Attachment")
	if existingAttach then
		attach = existingAttach
	else
		attach = Instance.new("Attachment")
		attach.Name = "SavageHub_Attachment"
		attach.Parent = part
	end

	local existingVF = part:FindFirstChild("SavageHub_VectorForce")
	if existingVF then
		vf = existingVF
	else
		vf = Instance.new("VectorForce")
		vf.Name = "SavageHub_VectorForce"
		vf.Parent = part
		vf.Attachment0 = attach
		vf.RelativeTo = Enum.ActuatorRelativeTo.World
		vf.Force = Vector3.new(0,0,0)
	end
end

local function destroyVectorForce()
	if forceConn then
		forceConn:Disconnect()
		forceConn = nil
	end
	if vf then
		pcall(function() vf:Destroy() end)
		vf = nil
	end
	if attach then
		pcall(function() attach:Destroy() end)
		attach = nil
	end
end

local function computeMoveDirection()
	local moveVec = Vector3.new()
	local cam = workspace.CurrentCamera
	if not cam then return moveVec end
	local cf = cam.CFrame
	local forward = Vector3.new(cf.LookVector.X, 0, cf.LookVector.Z)
	local right = Vector3.new(cf.RightVector.X, 0, cf.RightVector.Z)

	-- keyboard support (desktop)
	if UserInputService:IsKeyDown(Enum.KeyCode.W) then moveVec = moveVec + forward end
	if UserInputService:IsKeyDown(Enum.KeyCode.S) then moveVec = moveVec - forward end
	if UserInputService:IsKeyDown(Enum.KeyCode.A) then moveVec = moveVec - right end
	if UserInputService:IsKeyDown(Enum.KeyCode.D) then moveVec = moveVec + right end
	-- vertical control
	if UserInputService:IsKeyDown(Enum.KeyCode.Space) then moveVec = moveVec + Vector3.new(0,1,0) end
	if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then moveVec = moveVec - Vector3.new(0,1,0) end

	-- For mobile touch, there's no keyboard. Basic behavior:
	-- If user is touching anywhere besides UI, attempt to move toward camera look direction.
	-- More advanced virtual joystick can be added later; this is simple fallback.
	if UserInputService.TouchEnabled and #UserInputService:GetTouches() > 0 then
		-- if touch exists and no keyboard input, float forward relative to camera
		if moveVec.Magnitude == 0 then
			-- slight forward push when touching (makes flight usable on mobile)
			moveVec = forward
		end
	end

	if moveVec.Magnitude > 0 then
		return moveVec.Unit
	end
	return moveVec
end

local function startFly()
	if flying then return end
	if not hrp or not hrp.Parent then return end
	flying = true

	createVectorForceFor(hrp)

	-- reduce humanoid interference
	pcall(function() if humanoid and humanoid.Parent then humanoid.PlatformStand = true end end)

	forceConn = RunService.Heartbeat:Connect(function(dt)
		if not vf or not hrp or not hrp.Parent then return end

		-- mass of HRP (approx)
		local mass = 1
		pcall(function() mass = hrp:GetMass() end)

		-- compute target velocity based on input
		local dir = computeMoveDirection()
		local targetVel = Vector3.new(0,0,0)
		if dir.Magnitude > 0 then
			targetVel = dir * SavageHub.FlySpeed
		else
			targetVel = Vector3.new(0,0,0)
		end

		local currentVel = hrp.AssemblyLinearVelocity or Vector3.new(0,0,0)
		local responsiveness = math.max(1, SavageHub.FlyResponsiveness)
		local desiredAcc = (targetVel - currentVel) * responsiveness -- studs/s^2
		local rawForce = desiredAcc * mass -- N

		-- clamp force magnitude
		local maxForce = math.max(1, SavageHub.FlyForceMax)
		local clampedForce
		if rawForce.Magnitude > maxForce then
			clampedForce = rawForce.Unit * maxForce
		else
			clampedForce = rawForce
		end

		-- Apply the force
		vf.Force = clampedForce
	end)
end

local function stopFly()
	if not flying then return end
	flying = false
	destroyVectorForce()
	pcall(function()
		if humanoid and humanoid.Parent then
			humanoid.PlatformStand = false
			humanoid.WalkSpeed = SavageHub.WalkSpeed
			humanoid.JumpPower = SavageHub.JumpPower
		end
	end)
end

-- Monitor the Fly toggle and reapply settings each frame
RunService.Heartbeat:Connect(function()
	-- Ensure references are up-to-date (in case of respawn)
	if not char or not char.Parent then
		char = getCharacter()
	end
	humanoid = char:FindFirstChild("Humanoid") or humanoid
	hrp = char:FindFirstChild("HumanoidRootPart") or hrp

	if SavageHub.Fly and not flying then
		startFly()
	elseif not SavageHub.Fly and flying then
		stopFly()
	end

	-- While not flying, keep humanoid params in sync
	if not SavageHub.Fly and humanoid and humanoid.Parent then
		pcall(function()
			humanoid.WalkSpeed = SavageHub.WalkSpeed
			humanoid.JumpPower = SavageHub.JumpPower
		end)
	end
end)

-- Handle character respawn
player.CharacterAdded:Connect(function(c)
	wait(0.1)
	char = c
	humanoid = char:FindFirstChild("Humanoid") or humanoid
	hrp = char:FindFirstChild("HumanoidRootPart") or hrp
	-- re-enable flight if it was on
	if SavageHub.Fly then
		startFly()
	else
		if humanoid and humanoid.Parent then
			pcall(function()
				humanoid.WalkSpeed = SavageHub.WalkSpeed
				humanoid.JumpPower = SavageHub.JumpPower
			end)
		end
	end
end)

-- Cleanup on death
if humanoid then
	humanoid.Died:Connect(function()
		stopFly()
	end)
end

-- Initial apply
if humanoid and humanoid.Parent then
	pcall(function()
		humanoid.WalkSpeed = SavageHub.WalkSpeed
		humanoid.JumpPower = SavageHub.JumpPower
	end)
end

StarterGui:SetCore("SendNotification", {
	Title = "Savage Hub";
	Text = "Savage Hub loaded. Drag the title to move the menu. Use the bottom-left button on mobile to open/close. Use only in places you own.";
	Duration = 8;
})